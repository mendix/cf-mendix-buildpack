#!/usr/bin/env python
import os
import sys
import json
import errno
import shutil
import logging
import zipfile
import subprocess

logging.basicConfig(
    level=logging.INFO,
    stream=sys.stdout,
    format='%(levelname)s: %(message)s',
)

BUILD_DIR = sys.argv[1]
CACHE_DIR = os.path.join(sys.argv[2], 'bust')
DOT_LOCAL_LOCATION = os.path.join(BUILD_DIR, '.local')
BUILDPACK_DIR = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
USE_LOOSE_VERSION_CHECK = os.environ.get('FORCED_MXBUILD_URL') is not None
MXRUNTIME_DIR = os.path.join(BUILD_DIR, 'runtimes')

sys.path.insert(0, os.path.join(BUILDPACK_DIR, 'lib'))
import buildpackutil
from m2ee.version import MXVersion
import requests

logging.getLogger("requests").setLevel(logging.WARNING)


def contains_provided_mxruntime():
    return os.path.isdir(MXRUNTIME_DIR) and len(os.listdir(MXRUNTIME_DIR)) > 0


def remove_old_runtimes():
    def remove_empty_dir(path):
        if not os.path.isdir(path):
            return

        files = os.listdir(path)
        for f in files:
            child = os.path.join(path, f)
            remove_empty_dir(child)

        files = os.listdir(path)
        if len(files) == 0:
            os.rmdir(path)

    remove_empty_dir(MXRUNTIME_DIR)


def determine_provided_mxruntime_version():
    if contains_provided_mxruntime():
        remove_old_runtimes()
        versions = os.listdir(MXRUNTIME_DIR)
        if len(versions) == 1:
            if versions[0].endswith('.tar.gz'):
                if versions[0].startswith('mendix-'):
                    return versions[0][7:-7]
                if versions[0].startswith('mxbuild-'):
                    return versions[0][8:-7]
                raise Exception(
                    "Unsupported file name %s. Expects something starting "
                    "with 'mendix-' or 'mxbuild-'" % versions[0]
                )
            return versions[0]
        raise Exception(
            "Found multiple mxruntimes. Don't know which one to choose: %s "
            % versions
        )
    return None


def determine_mxbuild_dir():
    if contains_provided_mxruntime():
        return os.path.join(
            MXRUNTIME_DIR,
            determine_provided_mxruntime_version(),
            'modeler',
        ) 
    return os.path.join(
        'tmp',
        'mxbuild',
        'modeler',
    )


MXBUILD_DIR = determine_mxbuild_dir()


def contains_provided_mxbuild():
    return contains_provided_mxruntime() and os.path.isdir(MXBUILD_DIR)


def unpack(file_name, destination):
    if file_name.endswith('.deb'):
        subprocess.check_call(
            ['dpkg-deb', '-x', file_name, destination]
        )
    elif file_name.endswith('.tar.gz'):
        subprocess.check_call(
            ['tar', 'xf', file_name, '-C', destination]
        )
    else:
        raise Exception('do not know how to unpack {file_name}'.format(
            file_name=file_name
        ))


def unpack_mxruntime():
    if contains_provided_mxruntime():
        versions = os.listdir(MXRUNTIME_DIR)
        if len(versions) == 1 and versions[0].endswith('.tar.gz'):
            zip = os.path.join(MXRUNTIME_DIR, versions[0])
            unpack(zip, MXRUNTIME_DIR)
            os.unlink(zip)


def _get_java_version():
    versions = {
        '7': '7u80',
        '8': '8u45',
    }
    if determine_mendix_version() >= 5.18:
        default = '8'
    else:
        default = '7'
    main_java_version = os.getenv('JAVA_VERSION', default)

    if main_java_version not in versions.keys():
        raise Exception(
            'Invalid Java version specified: %s'
            % main_java_version
        )
    return versions[main_java_version]


def download(url, destination):
    logging.debug('downloading {url}'.format(url=url))
    with open(destination, 'w') as file_handle:
        response = requests.get(url, stream=True)
        if not response.ok:
            response.raise_for_status()
        for block in response.iter_content(4096):
            if not block:
                break
            file_handle.write(block)


def download_and_unpack(url, destination, use_cache=True):
    file_name = url.split('/')[-1]

    if use_cache:
        cache = CACHE_DIR
    else:
        cache = '/tmp/downloads'

    mkdir_p(cache)
    cached_location = os.path.join(cache, file_name)

    logging.info('preparing {file_name}'.format(file_name=file_name))

    if not os.path.isfile(cached_location):
        logging.info('downloading {file_name}'.format(file_name=file_name))
        download(url, cached_location)
    else:
        logging.debug('already present in cache {file_name}'.format(
            file_name=file_name
        ))

    unpack(cached_location, destination)

    logging.debug('source {file_name} retrieved & unpacked'.format(
        file_name=file_name
    ))


def mkdir_p(path):
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else:
            raise


def check_environment_variable(variable, explanation):
    value = os.environ.get(variable)
    if value is None:
        logging.warning(explanation)
        return False
    else:
        return True


def check_database_environment_variable():
    try:
        buildpackutil.get_database_config()
        return True
    except:
        logging.warning(
            'You should provide a DATABASE_URL by adding a database service '
            'to this application, it can be either MySQL or Postgres'
            'If this is the first push of a new app, set up a database service'
            'and push again afterwards'
        )
        return False


def check_admin_password_environment_variable():
    return check_environment_variable(
        'ADMIN_PASSWORD',
        'You should provide an ADMIN_PASSWORD environment variable'
    )


def set_up_java():
    logging.debug('begin download and install java')
    download_and_unpack(
        'http://cdn.mendix.com/mx-buildpack/'
        'oracle-java{java_version}-jre_{java_version}_amd64.deb'.format(
            java_version=_get_java_version()
        ),
        DOT_LOCAL_LOCATION,
    )
    mkdir_p(os.path.join(DOT_LOCAL_LOCATION, 'bin'))
    #  use ../ because path is different at staging, so final abspath unknown
    os.symlink(
        '../usr/lib/jvm/jre-{java_version}-oracle-x64/bin/java'.format(
            java_version=_get_java_version()
        ),
        os.path.join(DOT_LOCAL_LOCATION, 'bin', 'java')
    )
    logging.debug('end download and install java')


def set_up_java_sdk():
    logging.debug('begin download and install java sdk')
    destination = '/tmp/javasdk'
    mkdir_p(destination)
    download_and_unpack(
        'http://cdn.mendix.com/mx-buildpack/'
        'oracle-java{java_version}-jdk_{java_version}_amd64.deb'.format(
            java_version=_get_java_version()
        ),
        destination,
    )
    logging.debug('end download and install java sdk')


def preflight_check():
    logging.debug('pre-flight-check')
    if not all([
        check_database_environment_variable(),
        check_admin_password_environment_variable(),
    ]):
        raise Exception('missing environment variables')


def set_up_directory_structure():
    logging.debug('making directory structure')
    mkdir_p(DOT_LOCAL_LOCATION)
    for name in ['runtimes', 'log', 'database', 'data']:
        mkdir_p(os.path.join(BUILD_DIR, name))
    for name in ['files', 'tmp']:
        mkdir_p(os.path.join(BUILD_DIR, 'data', name))


def download_mendix_version():
    logging.debug('downloading mendix version')
    url = os.environ.get('FORCED_MXRUNTIME_URL')
    if url is None:
        use_cache = True
        url = 'http://cdn.mendix.com/runtime/mendix-%s.tar.gz' % str(
            determine_mendix_version()
        )
    else:
        use_cache = False
    download_and_unpack(
        url,
        MXRUNTIME_DIR,
        use_cache=use_cache,
    )


def copy_buildpack_resources():
    shutil.copy(
        os.path.join(BUILDPACK_DIR, 'm2ee.yaml'),
        os.path.join(DOT_LOCAL_LOCATION, 'm2ee.yaml'),
    )
    shutil.copy(
        os.path.join(BUILDPACK_DIR, 'start.py'),
        os.path.join(BUILD_DIR, 'start.py'),
    )
    shutil.copytree(
        os.path.join(BUILDPACK_DIR, 'lib'),
        os.path.join(BUILD_DIR, 'lib'),
    )
    if buildpackutil.get_new_relic_license_key():
        shutil.copytree(
            os.path.join(BUILDPACK_DIR, 'newrelic'),
            os.path.join(BUILD_DIR, 'newrelic'),
        )


def get_mpr_file():
    mprs = filter(lambda x: x.endswith('.mpr'), os.listdir(BUILD_DIR))
    if len(mprs) == 1:
        return os.path.join(BUILD_DIR, mprs[0])
    elif len(mprs) > 1:
        raise Exception('More than one .mpr file found, can not continue')
    else:
        return None


def is_source_push():
    if get_mpr_file() is not None:
        return True
    else:
        return False


def set_up_mono():
    mkdir_p('/tmp/mono')
    download_and_unpack(
        'http://cdn.mendix.com/mx-buildpack/mono-3.10.0.tar.gz',
        '/tmp/',
    )


def read_runtime_version_from_file_handle(file_handle):
    data = json.loads(file_handle.read())
    return data['RuntimeVersion']


def detect_mendix_version_from_mda():
    mda = get_mda_file()
    if mda is None:
        return None
    with zipfile.ZipFile(mda) as zf:
        with zf.open('model/metadata.json') as file_handle:
            return read_runtime_version_from_file_handle(file_handle)


def detect_mendix_version_from_local_fs():
    metadata_file = os.path.join(BUILD_DIR, 'model', 'metadata.json')
    if os.path.exists(metadata_file):
        with open(metadata_file) as file_handle:
            return read_runtime_version_from_file_handle(file_handle)
    return None


def detect_mendix_version_from_mpr():
    mpr = get_mpr_file()
    if mpr is None:
        return None
    import sqlite3
    try:
        conn = sqlite3.connect(get_mpr_file())
        try:
            cursor = conn.cursor()
            cursor.execute('SELECT _ProductVersion FROM _MetaData LIMIT 1')
            record = cursor.fetchone()
            return record[0]
        finally:
            conn.close()
    except:
        return None


def determine_mendix_version():
    mx_version = detect_mendix_version_from_mda()
    if mx_version is None:
        mx_version = detect_mendix_version_from_mpr()
    if mx_version is None:
        mx_version = detect_mendix_version_from_local_fs()
    if mx_version is None:
        raise Exception('Could not parse mendix version from provided app')
    return MXVersion(mx_version)


def set_up_mx_build():
    if not(contains_provided_mxbuild()):
        mendix_version = determine_mendix_version()

        mkdir_p(MXBUILD_DIR)

        url = os.environ.get('FORCED_MXBUILD_URL')
        if url is None:
            use_cache = True
            url = (
                'http://cdn.mendix.com/runtime/mxbuild-%s.tar.gz'
                % mendix_version
            )
        else:
            use_cache = False

        download_and_unpack(url, MXBUILD_DIR, use_cache=use_cache)


def run_mx_build():
    env = dict(os.environ)
    env['LD_LIBRARY_PATH'] = os.path.join(BUILDPACK_DIR, 'lib', 'mono-lib')
    subprocess.check_call([
        'sed',
        '-i',
        's|/app/vendor/mono/lib/libgdiplus.so|%s|g' % os.path.join(
            BUILDPACK_DIR, 'lib', 'mono-lib', 'libgdiplus.so'
        ),
        '/tmp/mono/etc/mono/config',
    ])
    args = [
        '/tmp/mono/bin/mono',
        '--config', '/tmp/mono/etc/mono/config',
        os.path.join(MXBUILD_DIR, 'mxbuild.exe'),
        '--output=' % os.path.join(BUILD_DIR, 'model.mda'),
        '--java-home=/tmp/javasdk/usr/lib/jvm'
        '/jdk-{java_version}-oracle-x64'.format(
            build_dir=BUILD_DIR,
            java_version=_get_java_version()
        ),
        '--java-exe-path=/tmp/javasdk/usr/lib/jvm'
        '/jdk-{java_version}-oracle-x64/bin/java'.format(
            build_dir=BUILD_DIR,
            java_version=_get_java_version()
        ),
    ]
    if USE_LOOSE_VERSION_CHECK:
        args.append('--loose-version-check')
        logging.warning(
            'Using forced mxbuild version, the model will be converted'
        )
    args.append(get_mpr_file())
    subprocess.check_call(args, env=env)

    for file_name in os.listdir(BUILD_DIR):
        path = os.path.join(BUILD_DIR, file_name)
        if not(file_name.endswith('.mda')) and not(
                file_name in ['.local', 'runtimes']
        ):
            if os.path.isdir(path):
                shutil.rmtree(path)
            else:
                os.unlink(path)


def get_mda_file():
    mdas = filter(lambda x: x.endswith('.mda'), os.listdir(BUILD_DIR))
    if len(mdas) == 1:
        return os.path.join(BUILD_DIR, mdas[0])
    elif len(mdas) > 1:
        raise Exception('More than one .mda file found, can not continue')
    else:
        return None


def unzip_mda():
    mda = get_mda_file()
    if mda is not None:
        zf = zipfile.ZipFile(mda)
        try:
            zf.extractall(BUILD_DIR)
        finally:
            zf.close()


if __name__ == '__main__':
    preflight_check()
    set_up_directory_structure()
    if contains_provided_mxruntime():
        USE_LOOSE_VERSION_CHECK = True

        unpack_mxruntime()
        runtime_version = determine_provided_mxruntime_version()
        app_requested_version = determine_mendix_version()
        logging.info(
            'Running app requiring version "%s" with provided runtime '
            'version "%s"' % (app_requested_version, runtime_version)
        )
        if runtime_version != app_requested_version:
            # fool m2ee to allow starting this app with the specified runtime
            os.rename(
                os.path.join(MXRUNTIME_DIR, runtime_version),
                os.path.join(MXRUNTIME_DIR, app_requested_version),
            )
    else:
        download_mendix_version()

    if is_source_push():
        logging.info('source push detected')
        set_up_java_sdk()
        set_up_mono()
        set_up_mx_build()
        run_mx_build()
    unzip_mda()
    set_up_java()
    copy_buildpack_resources()
    logging.info('buildpack compile completed')
